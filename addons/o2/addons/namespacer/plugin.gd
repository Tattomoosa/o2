@tool
extends EditorPlugin

const DirWatcher := H.Files.DirWatcher
const UPDATE_COMMAND := &"namespacer/update"
const SET_IDLE := &"namespacer/set_idle"
const TOP_INDEX_LINE := "# Generated by Namespacer - (https://github.com/Tattomoosa/o2)"
const INDEX_STATIC_GUARD := '## "Static" class\nfunc _init() -> void: assert(false, "Namespace class can\'t be instantiated")'

var dir_watcher : DirWatcher
var working := false
var roots : Array[String]
var class_roots : Array[String]
var l : O2.Logging.LogStream

func _enable_plugin() -> void:
	# Add autoloads here.
	pass

func _disable_plugin() -> void:
	# Remove autoloads here.
	pass

func _enter_tree() -> void:
	l = O2.instance.logger.add_substream(O2.Logging.LogStream.LogLevel.DEBUG, "Namespacer")
	EditorInterface.get_command_palette().add_command("Namespacer/Update", UPDATE_COMMAND, func(): _files_updated())
	EditorInterface.get_command_palette().add_command("Namespacer/Set Idle", SET_IDLE, func(): working = false)

func _ready() -> void:
	working = false
	dir_watcher = DirWatcher.new("res://", ["gd", "namespace", "namespace_class"], true)
	dir_watcher.files_created.connect(_files_updated.unbind(1))
	dir_watcher.files_deleted.connect(_files_updated.unbind(1))
	EditorInterface.get_resource_filesystem().filesystem_changed.connect(_update_dir_watcher)
	# _files_updated()

func _exit_tree() -> void:
	EditorInterface.get_command_palette().remove_command(UPDATE_COMMAND)
	EditorInterface.get_command_palette().remove_command(SET_IDLE)
	EditorInterface.get_resource_filesystem().filesystem_changed.disconnect(_update_dir_watcher)
	dir_watcher = null
	request_ready()

func _update_dir_watcher() -> void:
	if working:
		return
	while EditorInterface.get_resource_filesystem().is_scanning():
		await get_tree().process_frame
	dir_watcher.update()

func _files_updated() -> void:
	if working:
		l.debug("Update requested but Namespacer is busy...")
		return
	while EditorInterface.get_resource_filesystem().is_scanning():
		l.debug("Update requested but Filesystem is scanning, waiting...")
		await get_tree().process_frame
	working = true
	l.debug("Namespacer updating...")

	var dirs : Dictionary[String, Array] = {}

	# TODO be smarter lol
	roots = []
	class_roots = []
	var files := dir_watcher.get_files()
	for path in files:
		if path.get_file() == ".namespace":
			roots.push_back(path.get_base_dir())
			l.debug("Namespacer found root at: ", path)
		if path.get_file() == ".namespace_class":
			class_roots.push_back(path.get_base_dir())
			l.debug("Namespacer found class_name root at: ", path)
	var all_roots := []
	all_roots.append_array(roots)
	all_roots.append_array(class_roots)
	for i in range(files.size() - 1, -1, -1):
		var path := files[i]
		if !path.ends_with(".gd"):
			files.remove_at(i)
			continue
		var found_root := false
		for root in all_roots:
			if root in path:
				found_root = true
				break
		if !found_root:
			files.remove_at(i)

	# collect NamespaceEntries
	for file_path in files:
		var uid := ResourceLoader.get_resource_uid(file_path)
		if uid != -1:
			var entry := NamespaceEntry.new(uid)
			for root in all_roots:
				if root in entry.dir_path:
					dirs.get_or_add(entry.dir_path, []).push_back(entry)
		else:
			push_warning("Unkown UID - ", ResourceUID.id_to_text(uid), " (%s)" % file_path)

	# do everything in reverse now, so deeper entries are always created before their parents
	var rev_dirs : Array[String] = dirs.keys()
	rev_dirs.reverse()

	for dir in rev_dirs:
		var index_filename := _get_index_path(dir)
		var no_index_file := !FileAccess.file_exists(index_filename)
		_create_or_modify_index_file(dir, dirs[dir])
		if no_index_file:
			await _scan()
			if dir.get_base_dir() in dirs:
				var new_uid := ResourceLoader.get_resource_uid(index_filename)
				assert(new_uid != -1, "New file has invalid UID")
				var new_entry := NamespaceEntry.new(new_uid)
				dirs[new_entry.dir_path].push_back(new_entry)
	await _scan()
	l.debug("Namespacer done!")
	working = false

func _update_file(path: String) -> void:
	var fs := EditorInterface.get_resource_filesystem()
	fs.update_file(path)
	fs.reimport_files([path])

func _scan() -> void:
	var fs := EditorInterface.get_resource_filesystem()
	while fs.is_scanning():
		await get_tree().process_frame
	fs.scan()
	while fs.is_scanning():
		await get_tree().process_frame

func _is_dir_root(dir: String) -> bool:
	return dir in roots

func _get_index_path(path: String) -> String:
	return path.path_join("_index.gd")

func _create_or_modify_index_file(dir: String, entries: Array) -> bool:
	var file_path := _get_index_path(dir)
	var file := FileAccess.open(file_path, FileAccess.WRITE)
	var result := file.store_string(_get_index_content(dir, entries))
	if !result:
		push_error("Namespacer - failed to write index file '%s'" % file_path)
	return result

func _get_index_content(dir: String, entries: Array) -> String:
	var lines := PackedStringArray([TOP_INDEX_LINE])
	if dir in class_roots:
		lines.push_back("class_name %s" % dir.get_file())
	lines.push_back("")
	entries.sort_custom(
		func(a, b):
			return a.name[0] < b.name[0]
	)
	for entry in entries:
		lines.push_back(entry.get_line())
	lines.push_back("")
	lines.push_back(INDEX_STATIC_GUARD)
	lines.push_back("")
	lines.push_back("")
	return "\n".join(lines)

func _deleted_files(_files: PackedStringArray) -> void:
	_files_updated()

class NamespaceEntry extends RefCounted:
	var uid : int
	var path : String:
		get: return _get_path()
	var name : String:
		get: return _get_name()
	var is_index : bool:
		get: return _get_is_index()
	var index_name : String:
		get: return path.get_base_dir().get_file()
	var dir_path : String:
		get: return path.get_base_dir() if !is_index else path.get_base_dir().get_base_dir()
	
	func _init(p_uid: int) -> void:
		uid = p_uid

	func get_line() -> String:
		return 'const %s := preload("%s")' % [
			name if !is_index else index_name,
			ResourceUID.id_to_text(uid)
		]
	
	func _get_path() -> String:
		return ResourceUID.get_id_path(uid)
	
	func _get_name() -> String:
		return path.get_file().replace(".gd", "")

	func _get_is_index() -> bool:
		return name == "_index"