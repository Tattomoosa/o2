@tool
extends EditorPlugin

const TEST_ROOT := "res://test/RootNS"
const DirWatcher := O2.Helpers.Files.DirWatcher
const UPDATE_COMMAND := &"namespacer/update"
const SET_IDLE := &"namespacer/set_idle"
const TOP_INDEX_LINE := "# Generated by Namespacer - (<github link>)"

var dir_watcher : DirWatcher
var working := false

func _enable_plugin() -> void:
	# Add autoloads here.
	pass

func _disable_plugin() -> void:
	# Remove autoloads here.
	pass

func _enter_tree() -> void:
	EditorInterface.get_command_palette().add_command("Namespacer/Update", UPDATE_COMMAND, func(): _files_updated())
	EditorInterface.get_command_palette().add_command("Namespacer/Set Idle", SET_IDLE, func(): working = false)

func _ready() -> void:
	working = false
	dir_watcher = DirWatcher.new(TEST_ROOT, "gd")
	dir_watcher.files_created.connect(_files_updated.unbind(1))
	dir_watcher.files_deleted.connect(_files_updated.unbind(1))
	EditorInterface.get_resource_filesystem().filesystem_changed.connect(_update_dir_watcher)
	EditorInterface.get_resource_filesystem().resources_reload.connect(print)
	_files_updated()

func _exit_tree() -> void:
	EditorInterface.get_command_palette().remove_command(UPDATE_COMMAND)
	EditorInterface.get_command_palette().remove_command(SET_IDLE)
	EditorInterface.get_resource_filesystem().filesystem_changed.disconnect(_update_dir_watcher)
	dir_watcher = null

func _update_dir_watcher() -> void:
	if working:
		return
	while EditorInterface.get_resource_filesystem().is_scanning():
		await get_tree().process_frame
	dir_watcher.update()

func _files_updated() -> void:
	if working:
		print("Update requested but Namespacer is busy...")
		return
	while EditorInterface.get_resource_filesystem().is_scanning():
		print("Update requested but Filesystem is scanning, waiting...")
		await get_tree().process_frame
	working = true

	var dirs : Dictionary[String, Array] = {}
	var root := TEST_ROOT

	var files := dir_watcher.get_files()

	# collect NamespaceEntries
	for file_path in files:
		var uid := ResourceLoader.get_resource_uid(file_path)
		if uid != -1:
			var entry := NamespaceEntry.new(uid)
			if root in entry.dir_path:
				dirs.get_or_add(entry.dir_path, []).push_back(entry)
		else:
			push_warning("Unkown UID - ", ResourceUID.id_to_text(uid), " (%s)" % file_path)

	# do everything in reverse now, so deeper entries are always created before their parents
	var rev_dirs : Array[String] = dirs.keys()
	rev_dirs.reverse()

	for dir in rev_dirs:
		var index_filename := _get_index_path(dir)
		var no_index_file := !FileAccess.file_exists(index_filename)
		_create_or_modify_index_file(dir, dirs[dir], _is_dir_root(dir))
		if no_index_file:
			await _scan()
			if dir.get_base_dir() in dirs:
				var new_uid := ResourceLoader.get_resource_uid(index_filename)
				assert(new_uid != -1, "New file has invalid UID")
				var new_entry := NamespaceEntry.new(new_uid)
				dirs[new_entry.dir_path].push_back(new_entry)
	await _scan()
	working = false

func _update_file(path: String) -> void:
	var fs := EditorInterface.get_resource_filesystem()
	fs.update_file(path)
	fs.reimport_files([path])

func _scan() -> void:
	var fs := EditorInterface.get_resource_filesystem()
	while fs.is_scanning():
		await get_tree().process_frame
	fs.scan()
	while fs.is_scanning():
		await get_tree().process_frame
	print("DONE SCANNING")

func _is_dir_root(dir: String) -> bool:
	return dir == TEST_ROOT

func _get_index_path(path: String) -> String:
	return path.path_join("_index.gd")

func _create_or_modify_index_file(dir: String, entries: Array, is_root := false) -> bool:
	var file_path := _get_index_path(dir)
	var file := FileAccess.open(file_path, FileAccess.WRITE)
	var result := file.store_string(_get_index_content(dir, entries, is_root))
	if !result:
		push_error("Namespacer - failed to write index file '%s'" % file_path)
	return result

func _get_index_content(dir: String, entries: Array, is_root := false) -> String:
	var lines := PackedStringArray([TOP_INDEX_LINE])
	if is_root:
		lines.push_back("class_name %s" % dir.get_file())
	lines.push_back("")
	for entry in entries:
		lines.push_back(entry.get_line())
	lines.push_back("")
	return "\n".join(lines)

func _deleted_files(files: PackedStringArray) -> void:
	var root := TEST_ROOT
	for file in files:
		var relative_file := file.replace(root, "")
		print("Deleted: ", relative_file)

class NamespaceEntry extends RefCounted:
	var uid : int
	var path : String:
		get: return _get_path()
	var name : String:
		get: return _get_name()
	var is_index : bool:
		get: return _get_is_index()
	var index_name : String:
		get: return path.get_base_dir().get_file()
	var dir_path : String:
		get: return path.get_base_dir() if !is_index else path.get_base_dir().get_base_dir()
	
	func _init(p_uid: int) -> void:
		uid = p_uid

	func get_line() -> String:
		return 'const %s := preload("%s") # %s' % [name if !is_index else index_name, ResourceUID.id_to_text(uid), path]
	
	func _get_path() -> String:
		return ResourceUID.get_id_path(uid)
	
	func _get_name() -> String:
		return path.get_file().replace(".gd", "")

	func _get_is_index() -> bool:
		return name == "_index"
	
# class NewIndexNamespaceEntry extends NamespaceEntry:
# 	var _path : String

# 	func _init(p_path: String) -> void:
# 		super(-1)
# 		_path = p_path
	
# 	func _get_is_index() -> bool:
# 		return true
	
# 	func _get_path() -> String:
# 		return _path.path_join(name)
	
# 	func _get_name() -> String:
# 		return "_index.gd"
